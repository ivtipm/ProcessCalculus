#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
using namespace std;

/* Синхронизация потоков при общем доступе для записи в переменную */

int shared_var = 0;


// плохой пример: функция потока совершает неатомарную операцию над общей (с другими потоками) переменной
void foo_no_sync(){
    this_thread::sleep_for(chrono::milliseconds(rand()%10));

    for (unsigned i =0; i<100;i++) {
        // операция ++ не атомарна
        // поэтому возможно неопределённость параллелизма (состояние гонки):
        // например
        // оба потока прочитаю значение переменной
        // первый поток увеличит значение переменной на 1 и запишет новое значение
        // второй поток тоже увеличит значение переменой (прочитанное ранее) на 1 и запишет новое значение
        // в итоге переменная увеличится всего на 1, хотя инкремент ложен был произойти два раза
        shared_var++;
    }
}

// мьютекс должен быть доступен всем потокам, поэтому объявлен как глобальная переменная
mutex mtx;


// хороший пример: функция потока совершает операцию над общей переменной атомарно 
// код между mtx.lock() и mtx.unlock() может выполнят только один поток,
// поэтому никто не вклинится во время выполнения инкремента
// таким образом операция инкремента стала атомарной
void foo_sync(){
    this_thread::sleep_for(chrono::milliseconds(rand()%10));

    // Мьютекс заблокирован. Никто не помешает изменять переменную.
    for (unsigned i =0; i<100;i++) {
        // поток блокирует (отмечает) мьютекс
        // Остальные потоки будут ждать в строке ниже
        mtx.lock();
        
        shared_var++;
        
        // работа с переменной завершена, освободим
        mtx.unlock();    
    }
    
}


int main()
{
    unsigned Nth = 10000; // количество потоков
    vector<thread> threads_poll(Nth);

    cout << "Starting " << Nth << " threads" << endl;

    for (unsigned i = 0; i < Nth; i++){
//        threads_poll[i] = thread(foo_no_sync); // плохой пример: изменение общей переменной без синхронизации
        threads_poll[i] = thread(foo_sync);      // хороший пример: изменение общей переменной с синхронизацией
    }

    cout << "waiting for threads termination..." << endl;
    for(unsigned i = 0; i < Nth; i++){
        threads_poll[i].join();
    }

    cout << "shared_var = " << shared_var << endl;

    return 0;
}

// см. так же: метод try_lock - если мьютекс не принадлежит никакому потоку, тогда поток,
// вызвавший try_lock, становится его обладателем и метод возвращает true. В противном случае возвращает false.
// try_lock не блокирует текущий поток.


// см. еще один пример использования мьютекса в документации стандартной библиотеки:
// http://www.cplusplus.com/reference/mutex/mutex/
