# март 27

##  Лекция
Синхронизация с помощью мьютексов и условных переменных


## Лабораторное занятие
- За основу программы взять программу нахождения суммы массива (задание приведено в конце файла)
- Модифицировать эту программу так, чтобы каждый поток в конце своей работы записывал сумму в общую для всех потоков переменную.
- Общая для потоков переменная должна быть помещена в критическую секцию, защищённую мьютексом
- Создать большое число потоков (несколько сотен или больше), измерить время работы программы.
- Для надёжности измерений программа должна работать порядка нескольких секунд, лучше 20+ секунд. Если программа работает слишком быстро то тоит увеличить размер массива или сложность вычислений. Например суммировать не элементы массива и синусы этих элементов, или синусы синусов и т.д.
- Сравнить время работы данной программы, с тем что требуется программе без синхронизации потоков (предыдущий вариант программы, где суммирование частичных сумм потоков происходило в главном потоке)
- Как синхронизация повлияла на быстродействие программы? При каком числе потоков в данной программе, синхронизация заметно влияет на время выполнения программы?

### вопросы
- Какую проблему в данной задаче решает критическая секция, реализованная с помощью мьютекса?


#### задание с занятия 20 марта
- создать || программу вычисления суммы массива
- число потоков, которые будут считать сумму, должно задаваться пользователем
- Каждый поток должен записывать сумму в свою переменную, потом в основном потоке находится общая сумма
- Измерить время работы программы для разного числа потоков, составить таблицу (или график)
- Для надёжности измерений программа должна работать порядка нескольких секунд, лучше 20+ секунд. Если программа работает слишком быстро то тоит увеличить размер массива или сложность вычислений. Например суммировать не элементы массва и синусы этих элементов, или синусы синусов и т.д.
- Можно ли определить оптимальное число потоков по результатам измерений? Если да, то как это количество соотносится с числом ядер процессора и оптимальным числом потоков полученных программным способом (функция std::thread::hardware_concurrency() в C++)
